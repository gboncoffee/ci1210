00000000	0000000 zero zero 000 a0 0110011 # add a0, zero, zero
00000004	000000010100 zero 000 a1 0010011 # addi a1, zero, 20
00000008	000000000001 zero 000 a2 0010011 # addi a2, zero, 1
0000000c	000000000001 zero 000 a3 0010011 # addi a3, zero, 1
00000010	00001001000000000000 ra 1101111 # jal ra, fib (+36)
00000014        000001010000 zero 000 t0 0010011 # addi t0, zero, 80
00000018	0000000 zero zero 000 t1 0110011 # add t1, zero, zero
0000001c	0000000 t0 t1 000 10000 1100011 # beq t1, t0, exit (+16) (print)
00000020	0000000 t1 000 t2 0000011 # lw t2, 0(t1)
00000024	0000000 t1 t2 000 00000 0100011 # sw t2, 0(t1)
00000028	000000000001 t1 000 t1 0010011 # addi t1, t1, 1
0000002c	11111111000111111111 zero 1101111 # jal zero, print
00000030	00000000000000000000000000000000 # halt (exit)

# fib :: v (a0) -> tam (a1) -> e1 (a2) -> e2 (a3) -> ()
fib:	sw a2, 0(a0)		# na função operamos com as variáveis em ax
	sw a3, 4(a0)		# pois não há chamada de outras funções
	addi a0, a0, 8

	slli t0, a1, 2	# multiplica o tamanho do vetor por 4
	add t0, t0, a0	# salva o endereço final do vetor em t0

loop:	blt t0, a0, ret	# sai se passar do fim do vetor
	add t1, a2, a3	# aproveita ax como cache
	sw t1, 0(a0)		# v[i] = v[i - 1] + v[i - 2]
	add a2, a3, zero
	add a3, t1, zero
	addi a0, a0, 4	# aumenta o endereço em uma palavra
	jal zero, loop

ret: 	jalr zero, 0(ra)
