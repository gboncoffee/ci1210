\documentclass[twocolumn]{article}

\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc} % arruma utf8
\usepackage[T1]{fontenc} % arruma ctrl+c com utf8
\usepackage{indentfirst}
\usepackage[hidelinks]{hyperref, xurl} % \url
\usepackage{caption}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{svg}
\svgsetup{inkscapelatex=false}

\newcommand{\circuit}[1]{\includesvg[width=0.9\columnwidth]{#1}}

\title{Implementação Simulada de um Subconjunto da Microarquitetura RISC-V de 32
  Bits}
\author{Gabriel G. de Brito}

\begin{document}

\maketitle

\section{Introdução}

Esse trabalho apresenta o processo de implementação de um subconjunto de
instruções da microarquitetura de processadores RISC-V de 32 bits em um
simulador de lógica digital. Para provar a corretude da implementação, ela deve
rodar um programa em Assembly que computa a sequência de fibonacci em um vetor
em memória.

Tanto a microarquitetura quanto o programa foram implementados com sucesso,
inclusive com os requisitos sendo excedidos.

\section{A Microarquitetura}

Os requisitos do trabalho pedem que sejam implementados todos os registradores
da especificação da microarquitetura e as seguintes instruções\cite{spec}, no
simulador de lógica digital em CMOS Digital\cite{digital}:

\begin{itemize}
\item Instruções Aritméticas sem Imediato \\
  \begin{tabular}{ c c }
    \verb|add| & \hspace*{\fill} Adição ($+$) \\
    \verb|sub| & \hspace*{\fill} Subtração ($-$) \\
    \verb|xor| & \hspace*{\fill} OU Exclusivo lógico ($\oplus$) \\
    \verb|or| & \hspace*{\fill} OU lógico ($+$) \\
    \verb|and| & \hspace*{\fill} E lógico ($\cdot$) \\
    \verb|sll| & \hspace*{\fill} Shift lógico para esquerda ($<<$) \\
    \verb|slt| & \hspace*{\fill} Menor que ($<$)
  \end{tabular}
\item Instruções Aritméticas com Imediato \\
  \begin{tabular}{ c c }
    \verb|addi| & \hspace*{\fill} Adição ($+$)\\
    \verb|xori| & \hspace*{\fill} OU Exclusivo lógico ($\oplus$) \\
    \verb|ori| & \hspace*{\fill} OU lógico ($+$) \\
    \verb|andi| & \hspace*{\fill} E lógico ($\cdot$) \\
    \verb|slli| & \hspace*{\fill} Shift lógico para esquerda ($<<$)\\
    \verb|slti| & \hspace*{\fill} Menor que ($<$)
  \end{tabular}
\item Instruções de Manipulação de Memória \\
  \begin{tabular}{ c c }
    \verb|lw| & \hspace*{\fill} Carrega palavra \\
    \verb|sw| & \hspace*{\fill} Salva palavra
  \end{tabular}
\item Instruções de Controle de Fluxo \\
  \begin{tabular}{ c c }
    \verb|beq| & \hspace*{\fill} Break se igual a ($=$) \\
    \verb|bne| & \hspace*{\fill} Break se diferente de ($\neq$)\\
    \verb|blt| & \hspace*{\fill} Break se menor que ($<$) \\
    \verb|bge| & \hspace*{\fill} Break se maior ou igual a ($\geq$) \\
  \end{tabular}
\item Instruções de Salto \\
  \begin{tabular}{ c c }
    \verb|jal| & \hspace*{\fill} Salto para imediato \\
    \verb|jalr| & \hspace*{\fill} Salto para registrador
  \end{tabular}
\end{itemize}

Além disso, os requisitos pedem uma implementação em modelo de monociclo, e
permite que o endereçamento seja feito palavra-a-palavra ao invés de
byte-a-byte, por ser mais viável no simulador utilizado. A implementação
descrita aqui utiliza endereçamento byte-a-byte.

\section{Banco de Registradores}

O banco de registradores é um módulo com seis entradas e duas saídas:

\circuit{register-bank}

As entradas \textit{RS1i} e \textit{RS2i} selecionam quais registradores serão
conectados às saídas \textit{RS1} e \textit{RS2}, respectivamente. A entrada
\textit{RSA} seleciona um registrador para ter seu valor alterado, e a entrada
\textit{RDA} contém esse valor. Além disso, a entrada de 1 bit \textit{WR} deve
ser 1 para que haja escrita. A outra entrada de 1 bit, \textit{CLK}, deve ser
conectada ao clock da máquina.

As três entradas que endereçam registradores são entradas de 5 bits. Como cada
registrador armazena 32 bits, as entradas e saídas de dados possuem esse
tamanho.

Para selecionar os registradores para as saídas, usam-se dois
multiplexadores. Para selecionar o registrador que será alterado, usa-se um
demultiplexador no sinal de escrita.

Nota-se que o registrador endereçado por zero não é um registrador, mas sim uma
constante. Isso se dá pois na microarquitetura esse registrador não é afetado
por instruções de escrita, e sua leitura sempre deve resultar em zero.

\section{Unidade Lógica e Aritmética}

A Unidade Lógica e Aritmética (ULA) é um módulo com quatro entradas e duas
saídas.

\circuit{alu}

As entradas \textit{A} e \textit{B} possuem 32 bits cada, sendo os operandos a
serem utilizados na operação. As entradas \textit{OP3} e \textit{OP7} possuem 3
e 7 bits cada, respectivamente, e selecionam a operação a ser realizada pela
ULA. A maneira com que a seleção é feita é pensada para simplificar a lógica
necessária em outras partes do processador, devido à maneira com que as
instruções são codificadas.

A entrada \textit{OP3} está diretamente ligada à seleção de um multiplexador,
sendo o principal mecanismo de seleção da operação. A saída do somador da ULA é
selecionada tanto quando \textit{OP3} é 0 quanto 2. Porém, no caso de
\textit{OP3} ser 2, o bit mais significativo é utilizado para que a saída seja 0
ou 1, pois essa operação se trata de um ``menor que''. Subtraindo \textit{B} de
\textit{A}, o resultado é negativo caso \textit{A} seja menor que \textit{B},
situação em que o bit mais significativo do resultado será 1.

Além disso, um circuito acima do somador é utilizado para controlar se o mesmo
fará uma adição normal ou uma subtração. Quando \textit{OP3} é 0, a operação
pode ser tanto uma soma quanto uma subtração, dependendo do estado de
\textit{OP7}. No caso da soma, o último é 0, e no caso da subtração, é 32. Como
a operação desejada é uma subtração tanto no caso da subtração comum como no
``menor que'', verificamos se \textit{OP3} é 2 ou se \textit{OP7} é 32 (esse
último podemos verificar com apenas um bit do número, pois é a única operação
que a ULA faz onde \textit{OP7} não é zero). Caso afirmativo, o somador utiliza
o complemento do número em \textit{B} ao invés do original, e o valor 1 na
entrada do \textit{carry}. Devido às propriedades aritméticas do complemento de
2\cite{cornell-notes}, o resultado é a subtração de \textit{A} por \textit{B}.

A saída de 32 bits \textit{R} possui o resultado da operação em si, e a saída de
1 bit \textit{Zero} é construída a partir de uma operação NOR em todos os bits
do resultado. Dessa forma, essa saída será 1 apenas quando o resultado for
exatamente 0.

\section{Sinais}

Certos aspectos do funcionamento do processador são controlados por um módulo
chamado de processador de sinais. Esse componente possui uma entrada de 7 bits
por onde recebe o \textit{opcode} da instrução atual e outra entrada com os
demais 25 bits. Esse módulo produz as seguintes saídas:

\circuit{signal-proc}

\begin{itemize}
\item 3 bits na saída \textit{Func 3}, usado pela ULA na entrada \textit{OP3} e
  no controle de fluxo;
\item 7 bits na saída \textit{Func 7}, usado pela ULA na entrada \textit{OP7} e
  no controle de fluxo;
\item 1 bit na saída \textit{Load PC}, que indica se o banco de registradores
  deve receber como dado de escrita o valor do PC;
\item 1 bit na saída \textit{Load ALU}, que indica se o banco de registradores
  deve receber como dado de escrita o resultado da ULA;
\item 1 bit na saída \textit{Reg Store}, que indica se o sinal de escrita no
  banco de registradores deve ser ativo;
\item 1 bit na saída \textit{Mem Store}, que indica se o sinal de escrita da
  memória deve ser ativo;
\item 1 bit na saída \textit{Lau IMM}, que indica se a ULA deve receber na
  entrada \textit{B} um valor imediato ou o valor da saída \textit{RS2} do banco
  de registradores;
\end{itemize}

No caso em que ambos \textit{Load PC} e \textit{Load ALU} não estão em 1, o
banco de registradores deve receber a saída da memória.

Como todas as instruções que devem ser implementadas tem \textit{opcode}
começando com $0b11$, os dois primeiros bits são ignorados. Quanto ao resto, a
lógica é a seguinte:

\begin{itemize}
\item Caso o quinto bit seja 1, a instrução é aritmética de tipo R ou I. Nesses
  casos, ambos \textit{Func 3} e \textit{Func 7} estão codificados na instrução
  da mesma maneira que seus equivalentes na ULA, portanto basta
  propagá-los. Da mesma forma, o banco de registradores deve receber o resultado
  da ULA como dado de escrita, portanto \textit{Load ALU} é configurado para 1;
\item Caso o terceiro ou quinto bit seja 1, ou o sexto seja 0, a instrução
  precisa escrever no banco de registradores, então \textit{Reg Store} é
  configurado de acordo;
\item Caso o terceiro bit seja 1, a instrução é um salto, situação em que
  \textit{Load PC} deve ser 1;
\item Caso o sexto bit seja 1 e ambos quinto e sétimo 0, a instrução é um
  \textit{store}, portanto \textit{Load Mem} deve ser 1 para que o banco de
  registradores carregue dados da memória;
\item Caso o terceiro bit seja 0 e ambos sexto e sétimo 1, a instrução é um
  \textit{branch}. Nessa situação, a ULA deve realizar uma subtração de qualquer
  forma, portanto \textit{Func 3} é configurado para 0 e \textit{Func 7} para
  32.
\item Por fim, a ULA deve receber um imediato na entrada \textit{B} ao invés da
  saída de \textit{RS2} nas situações em que a instrução seja um salto, um
  \textit{load}, um \textit{store}, ou uma operação aritmética com
  imediato. Para que o sinal \textit{Lau IMM} seja configurado de acordo, ele é
  ligado à uma porta NAND que recebe como inputs a negação dos terceiro e quarto
  bits, um OR entre o quinto e o sétimo, e o sexto.
\end{itemize}

\section{Processamento de Imediato}

Como há diferentes formatos de instrução, é necessário construir valores
imediatos de maneira diferente para cada formato. O módulo de processamento de
imediato recebe os 32 bits da instrução na entrada \textit{Instruction} e
retorna um imediato de 32 bits na saída \textit{IMM}:

\circuit{imm-proc}

O módulo possui 4 circuitos separados para cada formato de instrução, e usa
portas de transmissão para garantir que haja somente uma entrada conectada à
saída. A montagem dos imediatos é extremamente simples, pois consiste em
reorganizar a ordem dos bits nas regiões da instrução, adicionar uma constante 0
como o primeiro bit dos imediatos que sofrem shift (formatos B e J), e extender
o imediato com sinal.

\begin{itemize}
\item A instrução é de tipo I caso seja uma instrução aritmética com imediato ou
  uma instrução de \textit{load}, ou seja, com \textit{opcode} $0b0010011$ ou
  $0b0000011$. Para averiguar, usa-se a expressão
  $(!O_3 O_2 \oplus  O_4) + !(O_5 + O_6)$.
  Para os \textit{opcode} válidos no subconjunto implementado na CPU, essa
  expressão é verdadeira somente para as instruções de tipo I.
\item A instrução é de tipo S somente no caso em que é um \textit{store}. Essas
  são as únicas instruções com quinto e sétimo bit 0 e sexto bit 1, portanto
  isso é verificado.
\item As instruções tipo B, da mesma maneira, são as únicas com sexto e sétimo
  bits 1 e terceiro e quinto bits 0.
\item As instruções tipo J, igualmente, são as únicas com terceiro e quarto bits
  1 e quinto bit 0.
\end{itemize}

Dessa maneira, a construção dos imediatos é simples e legível.

\section{Controle de Fluxo}

Um módulo separado processa sinais que controlam o fluxo de execução do
programa, ou seja, indicam o comportamento do PC (\textit{program counter}), um
registrador separado do banco de registradores que guarda o endereço da
instrução atual.

\circuit{pc-signal}

O módulo possui as entradas \textit{opcode}, de 7 bits, \textit{Zero out}, de 1
único bit (conectada à saída \textit{Zero} da ULA), \textit{Alu out}, de 32 bits
(conectada à saída da ULA), e \textit{Func 3}, de 3 bits. É importante notar que
a entrada \textit{Func 3} não está ligada à saída \textit{Func 3} do processador
de sinais. Ela está ligada diretamente à região ``func 3'' da instrução, que
está sempre no mesmo lugar.

A saída \textit{PC Alu} indica se o próximo valor do PC deve ser copiado do
resultado da ULA, e a saída \textit{+ IMM} indica se o próximo valor do PC deve
ser o resultado da soma do valor atual ao imediato. Ambas as saídas 0 indicam
que o próximo valor deve ser o atual somado a 4, pois instruções tem 32 bits,
portanto 4 bytes.

A lógica começa verificando se a instrução é uma instrução de salto ou
\textit{branch}. Para isso, verifica-se se os dois últimos bits dela estão em 1,
pois esses tipos de instrução são os únicos implementados onde isso
ocorre\cite{spec}. Caso falso, ambas as saídas automaticamente serão zero. Esse
efeito é alcançado ao ligar o teste (que usa uma simples porta AND) à seleção de
dois multiplexadores logo antes de cada saída, onde a opção 0 é ligada à
constantes 0.

A saída \textit{PC Alu} deve ser 1 somente quando a instrução é um
\verb|jalr|. Portanto, liga-se a saída à uma porta AND que verifica se os quarto
e quinto bit são 0 e o terceiro é 1.

A saída \textit{+ IMM} deve ser 1 caso a instrução seja um \textit{branch}
bem-sucedido ou um \verb|jal|. Liga-se uma porta OR à saída, comparando ambos os
testes. Caso a instrução seja \verb|jal|, o quarto bit do \textit{opcode} é 1,
portanto o teste é feito simplesmente ligando esse bit à entrada da porta
OR. Caso a instrução seja um branch, os dois últimos bits devem ser 1 e o
terceiro deve ser 0. Liga-se tudo isso num AND de 4 entradas, junto com o teste
do sucesso do \textit{branch}.

Para testar o sucesso do \textit{branch}, liga-se \textit{Func 3} à seleção de
um multiplexador. \textit{Func 3} é 2, 5, 6 e 7 somente em situações não
implementadas, portanto essas opções são ligadas em constantes 0.

\bibliography{referencias}{}
\bibliographystyle{ieeetr}

\end{document}
