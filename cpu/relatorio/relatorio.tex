\documentclass[twocolumn]{article}

\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc} % arruma utf8
\usepackage[T1]{fontenc} % arruma ctrl+c com utf8
\usepackage{indentfirst}
\usepackage[hidelinks]{hyperref, xurl} % \url
\usepackage{caption}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{svg}
\svgsetup{inkscapelatex=false}

\newcommand{\circuit}[1]{\includesvg[width=0.9\columnwidth]{#1}}

\title{Implementação Simulada de um Subconjunto da Microarquitetura RISC-V de 32
  Bits}
\author{Gabriel G. de Brito}

\begin{document}

\maketitle

\section{Introdução}

Esse trabalho apresenta o processo de implementação de um subconjunto de
instruções da microarquitetura de processadores RISC-V de 32 bits em um
simulador de lógica digital. Para provar a corretude da implementação, ela deve
rodar um programa em Assembly que computa a sequência de fibonacci em um vetor
em memória.

Tanto a microarquitetura quanto o programa foram implementados com sucesso,
inclusive com os requisitos sendo excedidos.

\section{A Microarquitetura}

Os requisitos do trabalho pedem que sejam implementados todos os registradores
da especificação da microarquitetura e as seguintes instruções\cite{spec}, no
simulador de lógica digital em CMOS Digital\cite{digital}:

\begin{itemize}
\item Instruções Aritméticas sem Imediato \\
  \begin{tabular}{ c c }
    \verb|add| & \hspace*{\fill} Adição ($+$) \\
    \verb|sub| & \hspace*{\fill} Subtração ($-$) \\
    \verb|xor| & \hspace*{\fill} OU Exclusivo lógico ($\oplus$) \\
    \verb|or| & \hspace*{\fill} OU lógico ($+$) \\
    \verb|and| & \hspace*{\fill} E lógico ($\cdot$) \\
    \verb|sll| & \hspace*{\fill} Shift lógico para esquerda ($<<$) \\
    \verb|slt| & \hspace*{\fill} Menor que ($<$)
  \end{tabular}
\item Instruções Aritméticas com Imediato \\
  \begin{tabular}{ c c }
    \verb|addi| & \hspace*{\fill} Adição ($+$)\\
    \verb|xori| & \hspace*{\fill} OU Exclusivo lógico ($\oplus$) \\
    \verb|ori| & \hspace*{\fill} OU lógico ($+$) \\
    \verb|andi| & \hspace*{\fill} E lógico ($\cdot$) \\
    \verb|slli| & \hspace*{\fill} Shift lógico para esquerda ($<<$)\\
    \verb|slti| & \hspace*{\fill} Menor que ($<$)
  \end{tabular}
\item Instruções de Manipulação de Memória \\
  \begin{tabular}{ c c }
    \verb|lw| & \hspace*{\fill} Carrega palavra \\
    \verb|sw| & \hspace*{\fill} Salva palavra
  \end{tabular}
\item Instruções de Controle de Fluxo \\
  \begin{tabular}{ c c }
    \verb|beq| & \hspace*{\fill} Break se igual a ($=$) \\
    \verb|bne| & \hspace*{\fill} Break se diferente de ($\neq$)\\
    \verb|blt| & \hspace*{\fill} Break se menor que ($<$) \\
    \verb|bge| & \hspace*{\fill} Break se maior ou igual a ($\geq$) \\
  \end{tabular}
\item Instruções de Salto \\
  \begin{tabular}{ c c }
    \verb|jal| & \hspace*{\fill} Salto para imediato \\
    \verb|jalr| & \hspace*{\fill} Salto para registrador
  \end{tabular}
\end{itemize}

Além disso, os requisitos pedem uma implementação em modelo de monociclo, e
permite que o endereçamento seja feito palavra-a-palavra ao invés de
byte-a-byte, por ser mais viável no simulador utilizado. A implementação
descrita aqui utiliza endereçamento byte-a-byte.

\section{Banco de Registradores}

O banco de registradores é um módulo com seis entradas e duas saídas:

\circuit{register-bank}

As entradas \textit{RS1i} e \textit{RS2i} selecionam quais registradores serão
conectados às saídas \textit{RS1} e \textit{RS2}, respectivamente. A entrada
\textit{RSA} seleciona um registrador para ter seu valor alterado, e a entrada
\textit{RDA} contém esse valor. Além disso, a entrada de 1 bit \textit{WR} deve
ser 1 para que haja escrita. A outra entrada de 1 bit, \textit{CLK}, deve ser
conectada ao clock da máquina.

As três entradas que endereçam registradores são entradas de 5 bits. Como cada
registrador armazena 32 bits, as entradas e saídas de dados possuem esse
tamanho.

Para selecionar os registradores para as saídas, usam-se dois
multiplexadores. Para selecionar o registrador que será alterado, usa-se um
demultiplexador no sinal de escrita.

Nota-se que o registrador endereçado por zero não é um registrador, mas sim uma
constante. Isso se dá pois na microarquitetura esse registrador não é afetado
por instruções de escrita, e sua leitura sempre deve resultar em zero.

\section{Unidade Lógica e Aritmética}

A Unidade Lógica e Aritmética (ULA) é um módulo com quatro entradas e duas
saídas.

\circuit{alu}

As entradas \textit{A} e \textit{B} possuem 32 bits cada, sendo os operandos a
serem utilizados na operação. As entradas \textit{OP3} e \textit{OP7} possuem 3
e 7 bits cada, respectivamente, e selecionam a operação a ser realizada pela
ULA. A maneira com que a seleção é feita é pensada para simplificar a lógica
necessária em outras partes do processador, devido à maneira com que as
instruções são codificadas.

A entrada \textit{OP3} está diretamente ligada à seleção de um multiplexador,
sendo o principal mecanismo de seleção da operação. A saída do somador da ULA é
selecionada tanto quando \textit{OP3} é 0 quanto 2. Porém, no caso de
\textit{OP3} ser 2, o bit mais significativo é utilizado para que a saída seja 0
ou 1, pois essa operação se trata de um ``menor que''. Subtraindo \textit{B} de
\textit{A}, o resultado é negativo caso \textit{A} seja menor que \textit{B},
situação em que o bit mais significativo do resultado será 1.

Além disso, um circuito acima do somador é utilizado para controlar se o mesmo
fará uma adição normal ou uma subtração. Quando \textit{OP3} é 0, a operação
pode ser tanto uma soma quanto uma subtração, dependendo do estado de
\textit{OP7}. No caso da soma, o último é 0, e no caso da subtração, é 32. Como
a operação desejada é uma subtração tanto no caso da subtração comum como no
``menor que'', verificamos se \textit{OP3} é 2 ou se \textit{OP7} é 32 (esse
último podemos verificar com apenas um bit do número, pois é a única operação
que a ULA faz onde \textit{OP7} não é zero). Caso afirmativo, o somador utiliza
o complemento do número em \textit{B} ao invés do original, e o valor 1 na
entrada do \textit{carry}. Devido às propriedades aritméticas do complemento de
2\cite{cornell-notes}, o resultado é a subtração de \textit{A} por \textit{B}.

A saída de 32 bits \textit{R} possui o resultado da operação em si, e a saída de
1 bit \textit{Zero} é construída a partir de uma operação NOR em todos os bits
do resultado. Dessa forma, essa saída será 1 apenas quando o resultado for
exatamente 0.

\section{Sinais}

Certos aspectos do funcionamento do processador são controlados por um módulo
chamado de processador de sinais. Esse componente possui uma entrada de 7 bits
por onde recebe o \textit{opcode} da instrução atual e outra entrada com os
demais 25 bits. Esse módulo produz as seguintes saídas:

\circuit{signal-proc}

\begin{itemize}
\item 3 bits na saída \textit{Func 3}, usado pela ULA na entrada \textit{OP3} e
  no controle de fluxo;
\item 7 bits na saída \textit{Func 7}, usado pela ULA na entrada \textit{OP7} e
  no controle de fluxo;
\item 1 bit na saída \textit{Load PC}, que indica se o banco de registradores
  deve receber como dado de escrita o valor do PC;
\item 1 bit na saída \textit{Load ALU}, que indica se o banco de registradores
  deve receber como dado de escrita o resultado da ULA;
\item 1 bit na saída \textit{Reg Store}, que indica se o sinal de escrita no
  banco de registradores deve ser ativo;
\item 1 bit na saída \textit{Mem Store}, que indica se o sinal de escrita da
  memória deve ser ativo;
\item 1 bit na saída \textit{Lau IMM}, que indica se a ULA deve receber na
  entrada \textit{B} um valor imediato ou o valor da saída \textit{RS2} do banco
  de registradores;
\end{itemize}

No caso em que ambos \textit{Load PC} e \textit{Load ALU} não estão em 1, o
banco de registradores deve receber a saída da memória.

Como todas as instruções que devem ser implementadas tem \textit{opcode}
começando com 0b11, os dois primeiros bits são ignorados. Quanto ao resto, a
lógica é a seguinte:

\begin{itemize}
\item Caso o quinto bit seja 1, a instrução é aritmética de tipo R ou I. Nesses
  casos, ambos \textit{Func 3} e \textit{Func 7} estão codificados na instrução
  da mesma maneira que seus equivalentes na ULA, portanto basta
  propagá-los. Da mesma forma, o banco de registradores deve receber o resultado
  da ULA como dado de escrita, portanto \textit{Load ALU} é configurado para 1;
\item Caso o terceiro ou quinto bit seja 1, ou o sexto seja 0, a instrução
  precisa escrever no banco de registradores, então \textit{Reg Store} é
  configurado de acordo;
\item Caso o terceiro bit seja 1, a instrução é um salto, situação em que
  \textit{Load PC} deve ser 1;
\item Caso o sexto bit seja 1 e ambos quinto e sétimo 0, a instrução é um
  \textit{store}, portanto \textit{Load Mem} deve ser 1 para que o banco de
  registradores carregue dados da memória;
\item Caso o terceiro bit seja 0 e ambos sexto e sétimo 1, a instrução é um
  \textit{branch}. Nessa situação, a ULA deve realizar uma subtração de qualquer
  forma, portanto \textit{Func 3} é configurado para 0 e \textit{Func 7} para
  32.
\item Por fim, a ULA deve receber um imediato na entrada \textit{B} ao invés da
  saída de \textit{RS2} nas situações em que a instrução seja um salto, um
  \textit{load}, um \textit{store}, ou uma operação aritmética com
  imediato. Para que o sinal \textit{Lau IMM} seja configurado de acordo, ele é
  ligado à uma porta NAND que recebe como inputs a negação dos terceiro e quarto
  bits, um OR entre o quinto e o sétimo, e o sexto.
\end{itemize}

\bibliography{referencias}{}
\bibliographystyle{ieeetr}

\end{document}
